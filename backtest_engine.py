import pandas as pd
import numpy as np
from typing import Dict, List, Tuple

from strategies.base_strategy import Strategy

class Backtester:
    """
    A vectorized backtester for trading strategies.

    This class runs a backtest on a given strategy and calculates a comprehensive
    set of performance metrics. It is designed to be fast and efficient for
    strategies that can be expressed in a vectorized manner.
    """
    def __init__(self, strategy: Strategy, data: pd.DataFrame, initial_capital: float, transaction_costs: Dict[str, float]):
        """
        Initializes the Backtester.

        Args:
            strategy (Strategy): An instance of a trading strategy.
            data (pd.DataFrame): The historical data to run the backtest on.
            initial_capital (float): The initial capital for the backtest.
            transaction_costs (Dict[str, float]): A dictionary of transaction costs,
                including 'brokerage' and 'slippage'.
        """
        self.strategy = strategy
        self.data = data
        self.initial_capital = initial_capital
        self.transaction_costs = transaction_costs
        self.reset()

    def reset(self) -> None:
        """Resets the backtester to its initial state."""
        self.cash = self.initial_capital
        self.position = 0
        self.trades: List[Dict[str, float]] = []
        self.equity_curve = pd.Series(dtype=float)

    def run(self) -> Tuple[Dict[str, float], pd.DataFrame, pd.Series]:
        """
        Runs the vectorized backtest.

        This method uses the signals generated by the strategy to simulate trades
        and calculate the equity curve.

        Returns:
            Tuple[Dict[str, float], pd.DataFrame, pd.Series]: A tuple containing the
            performance metrics, the trade log, and the equity curve.
        """
        signals = self.strategy.signals
        self.data['positions'] = signals['positions']

        # Calculate portfolio holdings
        portfolio = pd.DataFrame(index=self.data.index)
        portfolio['holdings'] = (self.data['positions'].cumsum() * self.data['close'])
        portfolio['cash'] = self.initial_capital - (self.data['positions'] * self.data['close']).cumsum()
<<<<<<< HEAD
        
=======

>>>>>>> ef30c4da16fe3884e4c2b68e5cde3930584545b3
        # Incorporate transaction costs
        num_trades = self.data['positions'].abs().sum()
        total_brokerage = num_trades * self.transaction_costs.get('brokerage', 0)
        portfolio['cash'] -= total_brokerage

        portfolio['total'] = portfolio['cash'] + portfolio['holdings']
        self.equity_curve = portfolio['total']

        # Generate trade log
        positions = self.data['positions'].to_frame()
        positions['price'] = self.data['close']
        positions = positions[positions['positions'] != 0]

        for i in range(len(positions)):
            trade = {
                "date": positions.index[i],
                "type": "BUY" if positions['positions'].iloc[i] == 1 else "SELL",
                "price": positions['price'].iloc[i],
                "quantity": 1 # Simplified for this example
            }
            self.trades.append(trade)
<<<<<<< HEAD
        
        trade_log = pd.DataFrame(self.trades)

        return self.calculate_performance(trade_log), trade_log, self.equity_curve

    def calculate_performance(self, trade_log: pd.DataFrame) -> Dict[str, float]:
=======

        trade_log = pd.DataFrame(self.trades)

        return self.calculate_performance(), trade_log, self.equity_curve

    def calculate_performance(self) -> Dict[str, float]:
>>>>>>> ef30c4da16fe3884e4c2b68e5cde3930584545b3
        """
        Calculates a comprehensive set of performance metrics.

        Returns:
            Dict[str, float]: A dictionary of performance metrics.
        """
        returns = self.equity_curve.pct_change().dropna()
<<<<<<< HEAD
        
=======

>>>>>>> ef30c4da16fe3884e4c2b68e5cde3930584545b3
        total_return = (self.equity_curve.iloc[-1] / self.initial_capital) - 1
        cagr = (self.equity_curve.iloc[-1] / self.initial_capital) ** (252 / len(self.equity_curve)) - 1 if len(self.equity_curve) > 0 else 0
        sharpe_ratio = returns.mean() / returns.std() * np.sqrt(252) if returns.std() != 0 else 0

        peak = self.equity_curve.expanding(min_periods=1).max()
        drawdown = (self.equity_curve - peak) / peak
        max_drawdown = drawdown.min()

        # Correctly calculate win rate
<<<<<<< HEAD
        if not trade_log.empty and len(trade_log) % 2 == 0:
            buy_prices = trade_log[trade_log['type'] == 'BUY']['price']
            sell_prices = trade_log[trade_log['type'] == 'SELL']['price']
            
            if len(buy_prices) == len(sell_prices):
                pnl = sell_prices.values - buy_prices.values
                wins = pnl[pnl > 0]
                win_rate = len(wins) / len(buy_prices) if len(buy_prices) > 0 else 0
            else:
                win_rate = 0
=======
        trade_log = pd.DataFrame(self.trades)
        if not trade_log.empty:
            trade_log['pnl'] = trade_log['price'].diff().shift(-1) * trade_log['quantity']
            wins = trade_log[trade_log['pnl'] > 0]
            win_rate = len(wins) / len(trade_log) if len(trade_log) > 0 else 0
>>>>>>> ef30c4da16fe3884e4c2b68e5cde3930584545b3
        else:
            win_rate = 0

        metrics = {
            "Total Return": f"{total_return:.2%}",
            "CAGR": f"{cagr:.2%}",
            "Sharpe Ratio": f"{sharpe_ratio:.2f}",
            "Max Drawdown": f"{max_drawdown:.2%}",
            "Win Rate": f"{win_rate:.2%}",
            "Total Trades": len(self.trades)
        }
        return metrics
